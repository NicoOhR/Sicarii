<!-- post.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FSAEStats</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Baskervville:ital@0;1&family=Bodoni+Moda:ital,opsz,wght@0,6..96,400..900;1,6..96,400..900&family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Newsreader:ital,opsz,wght@0,6..72,200..800;1,6..72,200..800&family=Wittgenstein:ital,wght@0,400..900;1,400..900&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="../tufte.css">
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
</head>
<body>
  <style>
  :not(pre) > code{
      background: #2b303b;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      overflow-x: auto;
  }
  pre.syntect,
  pre[class*="syntax"],
  pre.highlight,
  pre codeblock,          
  pre {
    max-width: 100%;
    overflow-x: auto;      
    overflow-y: hidden;     
    white-space: pre;        
    background: #111111
    -webkit-overflow-scrolling: touch;
  }
  </style>
  <nav class="nav editorial-nav">
    <div class="nav-center">
      <a href="../" class="nav-title divider-link">Sicarii</a>
    </div>
  </nav>

  <div class="editorial">
    <main class="post-container">
      <div class="post-header">
        <h1 class="post-title">FSAEStats</h1>
        <div class="post-meta">
          <div class="author">Nico OR</div>
          <div class="date">2025-05-08</div>
        </div>
      </div>

      <article class="post-content">
        <html><head></head><body><p>Motor racing, as a sport, is statistics-adjacent. In the
same way that a baseball game, or an entire series, can be recreated from
the key measures of players, the <em>story</em> of a race can be told almost
entierly from the statistics. The ups and downs and emotional highs of
a race, of course, can't quite be quantified (yet), but the image of
a driver, of their personality and strategy and legacy, is told in half
floats entries on a CSV.</p>
<p>Despite this, of course, the Formula Student competition provides the
results of the yearly competition in a PDF format, which I would say is
almost hostile to any form of analysis. And if it's hostile to
excel-spreadsheet-accountant type data analysis, it is outright aggressive
towards any attempts to do any data <em>science</em> with it.</p>
<p>Extracting the data from the PDF, which is in tabular format already, is
actually quite easy with <code>Camelot</code>. I honestly cannot reccomend this
package enough; I spent <a href="https://github.com/NicoOhR/FSAERawResults/commits/main/">far too
much</a> time trying
to clean up last years data which I extracted with <code>PdfPlumber</code>. Once
we have a CSV we can do as we'd like with the data, I wrote up a small
analysis on last years competition that I would like to revise, and will
probably push out on here soon (tm).</p>
<p>What follows is a largely unnecessary exercise in data engineering;
there's not enough data to necessitate a whole system to distribute it. It
would be just as easy to send someone CSVs, but what the hell, rust is
fun. The goal from the outset was to have an API that would take care of
the more tedious work of inner-joins and key-searches, and provide the end
user with an effecient format to work with. The final state of this
project is something that I am pretty happy with, even if getting there
was very messy. I wanted to keep the codebase lean, and reduce the amount
of boilerplate necessary, this precluded for me most ORMs. Since the most
natural representation of the data is as each event (autocross,
acceleration, endurance, etc.) as its own table in the database, since
each event has it's own fields and measures, that means that an ORM would
create a different struct for every single event, and then, in the rust
code, force an inordinante amount of very similar looking <code>match</code>
statements. Is this <em>really</em> an issue? No, not really, it just looks ugly.
Thus, begins the somewhat painful journey from Diesal to sqlX to SeaORM to
whatever else I could find. I frankly don't even remember some of the
experiments I made in forks that were never pushed.</p>
<p>What I wanted was to be able to handle everything generically and quickly.
A column/row from the acceleration results table is not essentially
different from a column/row from the endurance results table. I also
wanted to be flexible, all of which (and this is mostly a skill issue
I think) was pretty difficult with an ORM. So instead I opted to try using
<code>DuckDB</code> and communicate to my client with the Apache Arrow format.
Which, honestly, was only a little painful!</p>
<p>Critically, DuckDB allows the user to treat rows generically, and simply
treat every request as resulting in a <code>RecordBatch</code>.</p>
<p>Now to the code, which is really (and proudly) simple. Practically, we
define a <code>UserRequest</code> Struct, implement for it parsing and <code>handle</code> methods,
and use the information to query DuckDB:</p>
<html><head></head><body><pre><code class="language-Rust"><pre style="background-color:#282828;"><span style="color:#fa5c4b;">pub struct </span><span style="color:#8ec07c;">UserRequest </span><span style="color:#fdf4c1aa;">{
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">team</span><span style="color:#fdf4c1aa;">: String,
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">year</span><span style="color:#fdf4c1aa;">: String,
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">pub </span><span style="color:#fdf4c1;">event</span><span style="color:#fdf4c1aa;">: String,
</span><span style="color:#fdf4c1aa;">}
</span><span style="color:#fe8019;">...
</span><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">from_hash</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fdf4c1;">args</span><span style="color:#fdf4c1aa;">: </span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut </span><span style="color:#fdf4c1aa;">HashMap&lt;String, String&gt;) -&gt; Result&lt;Box&lt;</span><span style="color:#fa5c4b;">Self</span><span style="color:#fdf4c1aa;">&gt;, ParseError&gt; {
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> team </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> args.</span><span style="color:#fabd2f;">remove</span><span style="color:#fdf4c1aa;">(</span><span style="color:#b8bb26;">"team"</span><span style="color:#fdf4c1aa;">).</span><span style="color:#fabd2f;">ok_or</span><span style="color:#fdf4c1aa;">(ParseError::Missing(</span><span style="color:#b8bb26;">"team"</span><span style="color:#fdf4c1aa;">))</span><span style="color:#fe8019;">?</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> year </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> args.</span><span style="color:#fabd2f;">remove</span><span style="color:#fdf4c1aa;">(</span><span style="color:#b8bb26;">"year"</span><span style="color:#fdf4c1aa;">).</span><span style="color:#fabd2f;">ok_or</span><span style="color:#fdf4c1aa;">(ParseError::Missing(</span><span style="color:#b8bb26;">"year"</span><span style="color:#fdf4c1aa;">))</span><span style="color:#fe8019;">?</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> event </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> args.</span><span style="color:#fabd2f;">remove</span><span style="color:#fdf4c1aa;">(</span><span style="color:#b8bb26;">"event"</span><span style="color:#fdf4c1aa;">).</span><span style="color:#fabd2f;">ok_or</span><span style="color:#fdf4c1aa;">(ParseError::Missing(</span><span style="color:#b8bb26;">"event"</span><span style="color:#fdf4c1aa;">))</span><span style="color:#fe8019;">?</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fabd2f;">Ok</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fabd2f;">Box</span><span style="color:#fdf4c1aa;">::new(</span><span style="color:#fa5c4b;">Self </span><span style="color:#fdf4c1aa;">{ team, year, event }))
</span><span style="color:#fdf4c1aa;">}
</span><span style="color:#fdf4c1aa;">async </span><span style="color:#fa5c4b;">fn </span><span style="color:#8ec07c;">handle</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fdf4c1;">self</span><span style="color:#fdf4c1aa;">, </span><span style="color:#fdf4c1;">conn</span><span style="color:#fdf4c1aa;">: duckdb::Connection) -&gt; Result&lt;Vec&lt;arrow::array::RecordBatch&gt;&gt; {
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> query: </span><span style="color:#fabd2f;">String </span><span style="color:#fe8019;">= </span><span style="color:#fabd2f;">format!</span><span style="color:#fdf4c1aa;">(</span><span style="color:#b8bb26;">"SELECT * FROM </span><span style="color:#fdf4c1;">{}</span><span style="color:#b8bb26;"> WHERE Team = '</span><span style="color:#fdf4c1;">{}</span><span style="color:#b8bb26;">'"</span><span style="color:#fdf4c1aa;">, </span><span style="color:#fdf4c1;">self</span><span style="color:#fdf4c1aa;">.event, </span><span style="color:#fdf4c1;">self</span><span style="color:#fdf4c1aa;">.team);
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let mut</span><span style="color:#fdf4c1aa;"> stmt </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> conn.</span><span style="color:#fabd2f;">prepare</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1aa;">query)</span><span style="color:#fe8019;">?</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> rbs </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> stmt.</span><span style="color:#fabd2f;">query_arrow</span><span style="color:#fdf4c1aa;">([])</span><span style="color:#fe8019;">?</span><span style="color:#fdf4c1aa;">.</span><span style="color:#fabd2f;">collect</span><span style="color:#fdf4c1aa;">();
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fabd2f;">Ok</span><span style="color:#fdf4c1aa;">(rbs)
</span><span style="color:#fdf4c1aa;">}
</span></pre>
</code></pre></body></html>
<p>Then, from our server handler, we can easily leverage those functions to
generate the binary package</p>
<html><head></head><body><pre><code class="language-Rust"><pre style="background-color:#282828;"><span style="color:#fa5c4b;">match </span><span style="color:#fdf4c1aa;">(req.</span><span style="color:#fabd2f;">method</span><span style="color:#fdf4c1aa;">(), req.</span><span style="color:#fabd2f;">uri</span><span style="color:#fdf4c1aa;">().</span><span style="color:#fabd2f;">path</span><span style="color:#fdf4c1aa;">()) {
</span><span style="color:#fdf4c1aa;">    (</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1aa;">Method::</span><span style="color:#fdf4c1;">GET</span><span style="color:#fdf4c1aa;">, </span><span style="color:#b8bb26;">"/"</span><span style="color:#fdf4c1aa;">) </span><span style="color:#fe8019;">=&gt; </span><span style="color:#fabd2f;">Ok</span><span style="color:#fdf4c1aa;">(Response::new(</span><span style="color:#fabd2f;">full</span><span style="color:#fdf4c1aa;">(</span><span style="color:#b8bb26;">"GET the
</span><span style="color:#b8bb26;">    /team/year/event"</span><span style="color:#fdf4c1aa;">))),
</span><span style="color:#fdf4c1aa;">    (</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1aa;">Method::</span><span style="color:#fdf4c1;">GET</span><span style="color:#fdf4c1aa;">, </span><span style="color:#b8bb26;">"/event_arrow"</span><span style="color:#fdf4c1aa;">) </span><span style="color:#fe8019;">=&gt; </span><span style="color:#fdf4c1aa;">{ 
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let mut</span><span style="color:#fdf4c1aa;"> request </span><span style="color:#fe8019;">= </span><span style="color:#fabd2f;">parse_request</span><span style="color:#fdf4c1aa;">(req).await</span><span style="color:#fe8019;">?</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> response </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">UserRequest::from_hash(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut</span><span style="color:#fdf4c1aa;"> request)</span><span style="color:#fe8019;">?</span><span style="color:#fdf4c1aa;">.</span><span style="color:#fabd2f;">handle</span><span style="color:#fdf4c1aa;">(pool).await</span><span style="color:#fe8019;">?</span><span style="color:#fdf4c1aa;">; 
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let mut</span><span style="color:#fdf4c1aa;"> buf </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">Cursor::new(</span><span style="color:#fabd2f;">Vec</span><span style="color:#fdf4c1aa;">::new());
</span><span style="color:#fdf4c1aa;">    { 
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fa5c4b;">let mut</span><span style="color:#fdf4c1aa;"> writer </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">arrow::ipc::writer::StreamWriter::try_new(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut</span><span style="color:#fdf4c1aa;"> buf, </span><span style="color:#fe8019;">&amp;*</span><span style="color:#fdf4c1aa;">response[</span><span style="color:#d3869b;">0</span><span style="color:#fdf4c1aa;">].</span><span style="color:#fabd2f;">schema</span><span style="color:#fdf4c1aa;">())</span><span style="color:#fe8019;">?</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">        response.</span><span style="color:#fabd2f;">iter</span><span style="color:#fdf4c1aa;">().</span><span style="color:#fabd2f;">for_each</span><span style="color:#fdf4c1aa;">(|</span><span style="color:#fdf4c1;">x</span><span style="color:#fdf4c1aa;">| writer.</span><span style="color:#fabd2f;">write</span><span style="color:#fdf4c1aa;">(x).</span><span style="color:#fabd2f;">unwrap</span><span style="color:#fdf4c1aa;">());
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">        writer.</span><span style="color:#fabd2f;">finish</span><span style="color:#fdf4c1aa;">()</span><span style="color:#fe8019;">?</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">    } 
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fabd2f;">Ok</span><span style="color:#fdf4c1aa;">(Response::new(</span><span style="color:#fabd2f;">full</span><span style="color:#fdf4c1aa;">(buf.</span><span style="color:#fabd2f;">into_inner</span><span style="color:#fdf4c1aa;">()))) 
</span><span style="color:#fdf4c1aa;">} 
</span></pre>
</code></pre></body></html>
<p>From here, I anticipate adding a couple of things. Firstly, I need to add
the rest of the years to the database, which I've put off primarily
because of tedium. Then, I'd also like to give the user some more
convinient end points, like, for example the option to sample all years of
a teams performance for a specific event, or even a <code>summary</code> end
point which would give the user some convinient statistics. Finally, just
to finish it off I'd like to add Swagger Documentation for this API, and
maybe spend a weekend cobbeling together a front end exhibition for this.</p>
</body></html>
      </article>
    </main>
  </div>
  <script>
    window.MathJax = {
      loader: {load: ['[tex]/ams']},
      tex: {
        packages: {'[+]':['ams']},
        inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
        displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],
      },
      options: {
        // Only elements with one of these classes get processed
        processHtmlClass: 'math math-inline math-display',
        ignoreHtmlClass: 'no-mathjax'
      }
    };
  </script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

</body>
</html>