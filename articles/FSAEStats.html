<!-- post.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FSAEStats</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Baskervville:ital@0;1&family=Bodoni+Moda:ital,opsz,wght@0,6..96,400..900;1,6..96,400..900&family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Newsreader:ital,opsz,wght@0,6..72,200..800;1,6..72,200..800&family=Wittgenstein:ital,wght@0,400..900;1,400..900&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="../style.css">

</head>
<body>
  <style>
  :not(pre) > code{
      background: #2b303b;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      overflow-x: auto;
  }
  pre.syntect,
  pre[class*="syntax"],
  pre.highlight,
  pre codeblock,            /* fallback aliases if you use others */
  pre {
    max-width: 100%;
    overflow-x: auto;        /* ← horizontal scrollbar when needed */
    overflow-y: hidden;      /* no vertical bar */
    white-space: pre;        /* keep long lines on one line */
    background: #111111
    -webkit-overflow-scrolling: touch;
  }
  </style>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="../" class="nav-title divider-link">Sicarii</a>
      </li>
    </ul>
  </nav>

  <main class="post-container">
    <div class="post-header">
      <h1 class="post-title">FSAEStats</h1>
      <div class="post-meta">
        <div class="author">Nico OR</div>
        <div class="date">2025-05-08</div>
      </div>
    </div>

    <article class="post-content">
      <html><head></head><body><p>Motor racing, as a sport, is what I would call statistics-adjacent.
In the same way that a baseball game, or an entire series, can be
recreated from the key measures of players, the <em>story</em> of a race
can be told almost entierly from the statistics. The ups and downs and
emotional highs of a race, of course, can’t quite be quantified (yet),
but the image of a driver, of their personality and strategy and legacy,
is told in half floats entries on a CSV.</p>
<p>Despite this, of course, FSAE provides the results of the yearly
competition in a PDF format, which I would say is almost hostile to any
form of analysis. And if it’s hostile to excel-spreadsheet-accountant
type data analysis, it is outright aggressive towards any attempts to do
any data <em>science</em> with it.</p>
<p>Extracting the data from the PDF, which is in tabular format already,
is actually quite easy with <code>Camelot</code>. I honestly cannot
reccomend this package enough, I spent <a href="https://github.com/NicoOhR/FSAERawResults/commits/main/">far too
much</a> time trying to clean up last years data which I extracted with
<code>PdfPlumber</code>. Once we have a CSV we can do as we’d like with
the data, I wrote up a small analysis on last years competition that I
would like to revise, and will probably push out on here soon (tm).</p>
<p>What follows is a largely unnecessary exercise in data engineering;
there’s not enough data to necessitate any real engineering. But what
the hell, rust is fun. The final state of this project is something that
I am pretty happy with, even if getting there was messy. Think of this
project as the <em>frontend</em> of the <em>backend</em>, what a website
or data consumer would interact with in order to access your repackaged
data.</p>
<p>More than anything, I wanted to keep the codebase lean, and reduce
the amount of boilerplate necessary. This precluded for me most ORMs
(queue the boos). Since the most natural representation of the data is
as each event as its own table in the database, since each event has
it’s own fields and measures, that means that an ORM would create a
different struct for every single event, and then, in the rust code,
force an inordinante amount of very similar looking <code>match</code>
statements. Is this <em>really</em> an issue? No, not really, it just
looks ugly. Thus, begins the somewhat painful journey from Diesal to
sqlX to etc. etc. I frankly don’t even remember some of the experiments
I made in forks that were never pushed.</p>
<p>What I wanted was to be able to handle everything generically and
quickly. I also wanted to be flexible, all of which (and this is mostly
a skill issue I think) I thought were very difficult with an ORM. So
instead I opted to try using <code>DuckDB</code> and communicate to my
client with the Apache Arrow format. Which, honestly, was only a little
painful!</p>
<p>Critically, DuckDB allows the user to treat rows generically, and
simply treat every request as resulting in a
<code>RecordBatch</code>.</p>
<p>Now to the code, which is really (and proudly) simple. Practically,
we define a <code>UserRequest</code> Struct, implement for it parsing
and <code>handle</code> methods, and use the information to query
DuckDB:</p>
<html><head></head><body><pre class="rust"><pre style="background-color:#282828;"><span style="color:#fb4938;">pub struct </span><span style="color:#ead4af;">UserRequest {
</span><span style="color:#ead4af;">    </span><span style="color:#fb4938;">pub </span><span style="color:#ead4af;">team: String,
</span><span style="color:#ead4af;">    </span><span style="color:#fb4938;">pub </span><span style="color:#ead4af;">year: String,
</span><span style="color:#ead4af;">    </span><span style="color:#fb4938;">pub </span><span style="color:#ead4af;">event: String,
</span><span style="color:#ead4af;">}
</span><span style="color:#cab990;">...
</span><span style="color:#fd971f;">fn </span><span style="color:#8ab572;">from_hash</span><span style="color:#ead4af;">(</span><span style="color:#fd971f;">args</span><span style="color:#ead4af;">: </span><span style="color:#cab990;">&amp;</span><span style="color:#fb4938;">mut </span><span style="color:#ead4af;">HashMap&lt;String, String&gt;) -&gt; Result&lt;Box&lt;</span><span style="color:#fd971f;">Self</span><span style="color:#ead4af;">&gt;, ParseError&gt; {
</span><span style="color:#ead4af;">    </span><span style="color:#fd971f;">let</span><span style="color:#ead4af;"> team </span><span style="color:#cab990;">=</span><span style="color:#ead4af;"> args.</span><span style="color:#f1c050;">remove</span><span style="color:#ead4af;">(</span><span style="color:#aab11e;">"team"</span><span style="color:#ead4af;">).</span><span style="color:#f1c050;">ok_or</span><span style="color:#ead4af;">(ParseError::Missing(</span><span style="color:#aab11e;">"team"</span><span style="color:#ead4af;">))</span><span style="color:#cab990;">?</span><span style="color:#ead4af;">;
</span><span style="color:#ead4af;">    </span><span style="color:#fd971f;">let</span><span style="color:#ead4af;"> year </span><span style="color:#cab990;">=</span><span style="color:#ead4af;"> args.</span><span style="color:#f1c050;">remove</span><span style="color:#ead4af;">(</span><span style="color:#aab11e;">"year"</span><span style="color:#ead4af;">).</span><span style="color:#f1c050;">ok_or</span><span style="color:#ead4af;">(ParseError::Missing(</span><span style="color:#aab11e;">"year"</span><span style="color:#ead4af;">))</span><span style="color:#cab990;">?</span><span style="color:#ead4af;">;
</span><span style="color:#ead4af;">    </span><span style="color:#fd971f;">let</span><span style="color:#ead4af;"> event </span><span style="color:#cab990;">=</span><span style="color:#ead4af;"> args.</span><span style="color:#f1c050;">remove</span><span style="color:#ead4af;">(</span><span style="color:#aab11e;">"event"</span><span style="color:#ead4af;">).</span><span style="color:#f1c050;">ok_or</span><span style="color:#ead4af;">(ParseError::Missing(</span><span style="color:#aab11e;">"event"</span><span style="color:#ead4af;">))</span><span style="color:#cab990;">?</span><span style="color:#ead4af;">;
</span><span style="color:#ead4af;">
</span><span style="color:#ead4af;">    </span><span style="color:#f1c050;">Ok</span><span style="color:#ead4af;">(</span><span style="color:#f1c050;">Box</span><span style="color:#ead4af;">::new(</span><span style="color:#fd971f;">Self </span><span style="color:#ead4af;">{ team, year, event }))
</span><span style="color:#ead4af;">}
</span><span style="color:#ead4af;">async </span><span style="color:#fd971f;">fn </span><span style="color:#8ab572;">handle</span><span style="color:#ead4af;">(</span><span style="color:#fd971f;">self</span><span style="color:#ead4af;">, </span><span style="color:#fd971f;">conn</span><span style="color:#ead4af;">: duckdb::Connection) -&gt; Result&lt;Vec&lt;arrow::array::RecordBatch&gt;&gt; {
</span><span style="color:#ead4af;">    </span><span style="color:#fd971f;">let</span><span style="color:#ead4af;"> query: </span><span style="color:#f1c050;">String </span><span style="color:#cab990;">= </span><span style="color:#ead4af;">format!(</span><span style="color:#aab11e;">"SELECT * FROM </span><span style="color:#cc869b;">{}</span><span style="color:#aab11e;"> WHERE Team = '</span><span style="color:#cc869b;">{}</span><span style="color:#aab11e;">'"</span><span style="color:#ead4af;">, </span><span style="color:#f1c050;">self</span><span style="color:#ead4af;">.event, </span><span style="color:#f1c050;">self</span><span style="color:#ead4af;">.team);
</span><span style="color:#ead4af;">    </span><span style="color:#fd971f;">let </span><span style="color:#fb4938;">mut</span><span style="color:#ead4af;"> stmt </span><span style="color:#cab990;">=</span><span style="color:#ead4af;"> conn.</span><span style="color:#f1c050;">prepare</span><span style="color:#ead4af;">(</span><span style="color:#cab990;">&amp;</span><span style="color:#ead4af;">query)</span><span style="color:#cab990;">?</span><span style="color:#ead4af;">;
</span><span style="color:#ead4af;">    </span><span style="color:#fd971f;">let</span><span style="color:#ead4af;"> rbs </span><span style="color:#cab990;">=</span><span style="color:#ead4af;"> stmt.</span><span style="color:#f1c050;">query_arrow</span><span style="color:#ead4af;">([])</span><span style="color:#cab990;">?</span><span style="color:#ead4af;">.</span><span style="color:#f1c050;">collect</span><span style="color:#ead4af;">();
</span><span style="color:#ead4af;">    </span><span style="color:#f1c050;">Ok</span><span style="color:#ead4af;">(rbs)
</span><span style="color:#ead4af;">}</span></pre>
</pre></body></html>
<p>Then, from our server handler, we can easily leverage those functions
to generate the binary package</p>
<html><head></head><body><pre class="rust"><pre style="background-color:#282828;"><span style="color:#fb4938;">match </span><span style="color:#ead4af;">(req.</span><span style="color:#f1c050;">method</span><span style="color:#ead4af;">(), req.</span><span style="color:#f1c050;">uri</span><span style="color:#ead4af;">().</span><span style="color:#f1c050;">path</span><span style="color:#ead4af;">()) {
</span><span style="color:#ead4af;">    (</span><span style="color:#cab990;">&amp;</span><span style="color:#ead4af;">Method::</span><span style="color:#cc869b;">GET</span><span style="color:#ead4af;">, </span><span style="color:#aab11e;">"/"</span><span style="color:#ead4af;">) </span><span style="color:#cab990;">=&gt; </span><span style="color:#f1c050;">Ok</span><span style="color:#ead4af;">(Response::new(</span><span style="color:#f1c050;">full</span><span style="color:#ead4af;">(</span><span style="color:#aab11e;">"GET the
</span><span style="color:#aab11e;">    /team/year/event"</span><span style="color:#ead4af;">))),
</span><span style="color:#ead4af;">    (</span><span style="color:#cab990;">&amp;</span><span style="color:#ead4af;">Method::</span><span style="color:#cc869b;">GET</span><span style="color:#ead4af;">, </span><span style="color:#aab11e;">"/event_arrow"</span><span style="color:#ead4af;">) </span><span style="color:#cab990;">=&gt; </span><span style="color:#ead4af;">{ 
</span><span style="color:#ead4af;">    </span><span style="color:#fb4938;">let mut</span><span style="color:#ead4af;"> request </span><span style="color:#cab990;">= </span><span style="color:#f1c050;">parse_request</span><span style="color:#ead4af;">(req).await</span><span style="color:#cab990;">?</span><span style="color:#ead4af;">;
</span><span style="color:#ead4af;">    </span><span style="color:#fb4938;">let</span><span style="color:#ead4af;"> response </span><span style="color:#cab990;">= </span><span style="color:#ead4af;">UserRequest::from_hash(</span><span style="color:#cab990;">&amp;</span><span style="color:#fb4938;">mut</span><span style="color:#ead4af;"> request)</span><span style="color:#cab990;">?</span><span style="color:#ead4af;">.</span><span style="color:#f1c050;">handle</span><span style="color:#ead4af;">(pool).await</span><span style="color:#cab990;">?</span><span style="color:#ead4af;">; 
</span><span style="color:#ead4af;">    </span><span style="color:#fb4938;">let mut</span><span style="color:#ead4af;"> buf </span><span style="color:#cab990;">= </span><span style="color:#ead4af;">Cursor::new(</span><span style="color:#f1c050;">Vec</span><span style="color:#ead4af;">::new());
</span><span style="color:#ead4af;">    { 
</span><span style="color:#ead4af;">        </span><span style="color:#fb4938;">let mut</span><span style="color:#ead4af;"> writer </span><span style="color:#cab990;">= </span><span style="color:#ead4af;">arrow::ipc::writer::StreamWriter::try_new(</span><span style="color:#cab990;">&amp;</span><span style="color:#fb4938;">mut</span><span style="color:#ead4af;"> buf, </span><span style="color:#cab990;">&amp;*</span><span style="color:#ead4af;">response[</span><span style="color:#cc869b;">0</span><span style="color:#ead4af;">].</span><span style="color:#f1c050;">schema</span><span style="color:#ead4af;">())</span><span style="color:#cab990;">?</span><span style="color:#ead4af;">;
</span><span style="color:#ead4af;">
</span><span style="color:#ead4af;">        response.</span><span style="color:#f1c050;">iter</span><span style="color:#ead4af;">().</span><span style="color:#f1c050;">for_each</span><span style="color:#ead4af;">(|</span><span style="color:#fd971f;">x</span><span style="color:#ead4af;">| writer.</span><span style="color:#f1c050;">write</span><span style="color:#ead4af;">(x).</span><span style="color:#f1c050;">unwrap</span><span style="color:#ead4af;">());
</span><span style="color:#ead4af;">
</span><span style="color:#ead4af;">        writer.</span><span style="color:#f1c050;">finish</span><span style="color:#ead4af;">()</span><span style="color:#cab990;">?</span><span style="color:#ead4af;">;
</span><span style="color:#ead4af;">    } 
</span><span style="color:#ead4af;">    </span><span style="color:#f1c050;">Ok</span><span style="color:#ead4af;">(Response::new(</span><span style="color:#f1c050;">full</span><span style="color:#ead4af;">(buf.</span><span style="color:#f1c050;">into_inner</span><span style="color:#ead4af;">()))) 
</span><span style="color:#ead4af;">} </span></pre>
</pre></body></html>
<p>(I request, most humbly, if you would kindly ignore the
deref-ref)</p>
<p>From here, I anticipate adding a couple of things. Firstly, I need to
add the rest of the years to the database, which I’ve put off primarily
because of tedium. Then, I’d also like to give the user some more
convinient end points, like, for example the option to sample all years
of a teams performance for a specific event, or even a
<code>summary</code> end point which would give the user some convinient
statistics. Finally, just to finish it off I’d like to add Swagger
Documentation for this API, and maybe spend a weekend cobbeling together
a front end exhibition for this.</p>
</body></html>
    </article>
  </main>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>

  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</body>
</html>
