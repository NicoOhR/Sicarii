<!-- post.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Great Value Three Body Problem</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Baskervville:ital@0;1&family=Bodoni+Moda:ital,opsz,wght@0,6..96,400..900;1,6..96,400..900&family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Newsreader:ital,opsz,wght@0,6..72,200..800;1,6..72,200..800&family=Wittgenstein:ital,wght@0,400..900;1,400..900&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="../tufte.css">
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
</head>
<body>
  <style>
  :not(pre) > code{
      background: #2b303b;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      overflow-x: auto;
  }
  pre.syntect,
  pre[class*="syntax"],
  pre.highlight,
  pre codeblock,          
  pre {
    max-width: 100%;
    overflow-x: auto;      
    overflow-y: hidden;     
    white-space: pre;        
    background: #111111
    -webkit-overflow-scrolling: touch;
  }
  </style>
  <nav class="nav editorial-nav">
    <div class="nav-center">
      <a href="../" class="nav-title divider-link">Sicarii</a>
    </div>
  </nav>

  <div class="editorial">
    <main class="post-container">
      <div class="post-header">
        <h1 class="post-title">Great Value Three Body Problem</h1>
        <div class="post-meta">
          <div class="author">Nico OR</div>
          <div class="date">2025-03-30</div>
        </div>
      </div>

      <article class="post-content">
        <html><head></head><body><p>The three body problem is a relatively well known scenario in classical
mechanics, as well as a pretty good series of novels, with no closed form
solution. It's comprised of three, equal mass, bodies in space (the "three
body" part) and the aim is describing the movement caused by gravitational
attraction between the bodies(the "problem" part). Some restricted variations of the
problem have solutions, and it's most generally described as a system of
three second order vector differential equations, or a really ugly
eighteen part Hamiltonian differential scalar equations. In an attempt to
avoid the physics, I set out to model the problem in
a close-enough-to-have-fun simulation.</p>
<p>The simulation is set up in Rust, using Bevy + Rapier 2D. I hesitated to commit
to using Bevy since I thought it would be overkill for what I needed it for,
and that was somewhat true, but this <a href="https://www.youtube.com/watch?v=PND2Wpy6U-E">particularly interesting</a> podcast convinced me
to bite the bullet and figure out Bevy's ECS system. With a little bit of
hindsight, I can say confidently it would have been easier to use Rapier
as a headless physics solver and simply visualize using some plotting
library down the pipeline. If I wanted to eventually <em>solve</em> the problem,
I needed a way for the program to communicate with external program;
since, unfortunatly, <a href="https://www.arewelearningyet.com/">we are not learning
yet</a> and I also just wanted to play
around with IPC. I chose to use gRPC by way of Tokio's Tonic since
I already had the mind to write somewhat effecient code considering the
computational demand of the problem. To complete the chain, I wrote up
a small python client to interact with the simulation.</p>
<p>The simulation is done in the system <code>gravity_update()</code>, which, for
every combination of two bodies, fetches the mass and location of the
bodies, then calculates and applies the gravitational force and its
opposite that the bodies apply on each other. The <code>gravitational_force()</code>,
calculation is adapted from Newton's Gravitational Law.
(No, that's not the real gravitational constant)</p>
<html><head></head><body><pre><code class="language-Rust"><pre style="background-color:#282828;"><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">gravitational_force</span><span style="color:#fdf4c1aa;">(
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fdf4c1;">mass1</span><span style="color:#fdf4c1aa;">: </span><span style="color:#fa5c4b;">f32</span><span style="color:#fdf4c1aa;">,
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fdf4c1;">mass2</span><span style="color:#fdf4c1aa;">: </span><span style="color:#fa5c4b;">f32</span><span style="color:#fdf4c1aa;">,
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fdf4c1;">position1</span><span style="color:#fdf4c1aa;">: Vector2&lt;</span><span style="color:#fa5c4b;">f32</span><span style="color:#fdf4c1aa;">&gt;,
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fdf4c1;">position2</span><span style="color:#fdf4c1aa;">: Vector2&lt;</span><span style="color:#fa5c4b;">f32</span><span style="color:#fdf4c1aa;">&gt;,
</span><span style="color:#fdf4c1aa;">) -&gt; Vector2&lt;</span><span style="color:#fa5c4b;">f32</span><span style="color:#fdf4c1aa;">&gt; {
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> r </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> position2 </span><span style="color:#fe8019;">-</span><span style="color:#fdf4c1aa;"> position1;
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> direction </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> r.</span><span style="color:#fabd2f;">norm</span><span style="color:#fdf4c1aa;">();
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> f_mag </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1000.0 </span><span style="color:#fe8019;">* </span><span style="color:#fdf4c1aa;">((mass1 </span><span style="color:#fe8019;">*</span><span style="color:#fdf4c1aa;"> mass2) </span><span style="color:#fe8019;">/</span><span style="color:#fdf4c1aa;"> direction.</span><span style="color:#fabd2f;">powi</span><span style="color:#fdf4c1aa;">(</span><span style="color:#d3869b;">2</span><span style="color:#fdf4c1aa;">));
</span><span style="color:#fdf4c1aa;">    r.</span><span style="color:#fabd2f;">normalize</span><span style="color:#fdf4c1aa;">() </span><span style="color:#fe8019;">*</span><span style="color:#fdf4c1aa;"> f_mag
</span><span style="color:#fdf4c1aa;">}
</span></pre>
</code></pre></body></html>
<p>Briefly, I added vectors to show more obviously the velocities of the
bodies during the simulation.</p>
<html><head></head><body><pre><code class="language-Rust"><pre style="background-color:#282828;"><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">setup_vectors</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fa5c4b;">mut </span><span style="color:#fdf4c1;">commands</span><span style="color:#fdf4c1aa;">: Commands, </span><span style="color:#fdf4c1;">query_bodies</span><span style="color:#fdf4c1aa;">: Query&lt;</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1aa;">Transform&gt;) {
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">for </span><span style="color:#fe8019;">_ in</span><span style="color:#fdf4c1aa;"> query_bodies.</span><span style="color:#fabd2f;">iter</span><span style="color:#fdf4c1aa;">() {
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> line </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">shapes::Line(Vec2::</span><span style="color:#fdf4c1;">ZERO</span><span style="color:#fdf4c1aa;">, Vec2::new(</span><span style="color:#d3869b;">0.0</span><span style="color:#fdf4c1aa;">, </span><span style="color:#d3869b;">0.0</span><span style="color:#fdf4c1aa;">));
</span><span style="color:#fdf4c1aa;">        commands.</span><span style="color:#fabd2f;">spawn</span><span style="color:#fdf4c1aa;">((
</span><span style="color:#fdf4c1aa;">            ShapeBundle {
</span><span style="color:#fdf4c1aa;">                path: GeometryBuilder::build_as(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1aa;">line),
</span><span style="color:#fdf4c1aa;">                </span><span style="color:#fe8019;">..</span><span style="color:#fabd2f;">default</span><span style="color:#fdf4c1aa;">()
</span><span style="color:#fdf4c1aa;">            },
</span><span style="color:#fdf4c1aa;">            Stroke::new(Color::</span><span style="color:#fdf4c1;">WHITE</span><span style="color:#fdf4c1aa;">, </span><span style="color:#d3869b;">5.0</span><span style="color:#fdf4c1aa;">), </span><span style="font-style:italic;color:#928374;">// Spawn in lines
</span><span style="color:#fdf4c1aa;">        ));
</span><span style="color:#fdf4c1aa;">    }
</span><span style="color:#fdf4c1aa;">}
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fa5c4b;">pub fn </span><span style="color:#8ec07c;">vector_update</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fdf4c1;">query_body</span><span style="color:#fdf4c1aa;">: Query&lt;(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1aa;">Transform, </span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1aa;">Velocity)&gt;, </span><span style="color:#fa5c4b;">mut </span><span style="color:#fdf4c1;">query_path</span><span style="color:#fdf4c1aa;">: Query&lt;</span><span style="color:#fe8019;">&amp;</span><span style="color:#fa5c4b;">mut</span><span style="color:#fdf4c1aa;"> Path&gt;) {
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">for </span><span style="color:#fdf4c1aa;">((transform, velocity), </span><span style="color:#fa5c4b;">mut</span><span style="color:#fdf4c1aa;"> path) </span><span style="color:#fe8019;">in</span><span style="color:#fdf4c1aa;"> query_body.</span><span style="color:#fabd2f;">iter</span><span style="color:#fdf4c1aa;">().</span><span style="color:#fabd2f;">zip</span><span style="color:#fdf4c1aa;">(query_path.</span><span style="color:#fabd2f;">iter_mut</span><span style="color:#fdf4c1aa;">()) {
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> center_of_mass </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> transform.translation.</span><span style="color:#fabd2f;">truncate</span><span style="color:#fdf4c1aa;">();
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> vel </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> velocity.linvel;
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fa5c4b;">let</span><span style="color:#fdf4c1aa;"> new_line </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">shapes::Line(center_of_mass, center_of_mass </span><span style="color:#fe8019;">+</span><span style="color:#fdf4c1aa;"> vel);
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fe8019;">*</span><span style="color:#fdf4c1aa;">path </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">ShapePath::build_as(</span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1aa;">new_line);
</span><span style="color:#fdf4c1aa;">    }
</span><span style="color:#fdf4c1aa;">}
</span></pre>
</code></pre></body></html>
<p>The gRPC server handles the setting of initial conditions (the solution,
as it were), as well as resetting the simulation and handing out the
current state of the simulation. The <code>SimState</code> message is simply an
array of <code>BodyAttributes</code>, values necessary to make the calculations
for the simulation.</p>
<html><head></head><body><pre><code class="language-C++"><pre style="background-color:#282828;"><span style="color:#fdf4c1aa;">syntax </span><span style="color:#fe8019;">= </span><span style="color:#b8bb26;">"proto3"</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">package simulation;
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">service Sim {
</span><span style="color:#fdf4c1aa;">  rpc </span><span style="color:#fdf4c1;">StateReply(SimCurrentStateReq) returns (SimState) </span><span style="color:#fdf4c1aa;">{}
</span><span style="color:#fdf4c1aa;">  rpc </span><span style="color:#fdf4c1;">SetConfiguration(SimState) returns (ConfigValid) </span><span style="color:#fdf4c1aa;">{}
</span><span style="color:#fdf4c1aa;">}
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">message </span><span style="color:#fdf4c1;">SimCurrentStateReq{
</span><span style="color:#fdf4c1;">  optional string bodyID </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1</span><span style="color:#fdf4c1;">;
</span><span style="color:#fdf4c1;">}
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">message </span><span style="color:#fdf4c1;">Vec2D{
</span><span style="color:#fdf4c1;">  </span><span style="color:#fa5c4b;">float</span><span style="color:#fdf4c1;"> x </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1</span><span style="color:#fdf4c1;">;
</span><span style="color:#fdf4c1;">  </span><span style="color:#fa5c4b;">float</span><span style="color:#fdf4c1;"> y </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">2</span><span style="color:#fdf4c1;">;
</span><span style="color:#fdf4c1;">}
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">message </span><span style="color:#fdf4c1;">ConfigValid{
</span><span style="color:#fdf4c1;">  </span><span style="color:#fa5c4b;">bool</span><span style="color:#fdf4c1;"> succeeded </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1</span><span style="color:#fdf4c1;">;
</span><span style="color:#fdf4c1;">}
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">message </span><span style="color:#fdf4c1;">BodyAttributes{
</span><span style="color:#fdf4c1;">  Vec2D velocity </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1</span><span style="color:#fdf4c1;">;
</span><span style="color:#fdf4c1;">  Vec2D position </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">2</span><span style="color:#fdf4c1;">;
</span><span style="color:#fdf4c1;">  </span><span style="color:#fa5c4b;">float</span><span style="color:#fdf4c1;"> mass </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">3</span><span style="color:#fdf4c1;">;
</span><span style="color:#fdf4c1;">  uint32 bodyID </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">4</span><span style="color:#fdf4c1;">;
</span><span style="color:#fdf4c1;">}
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">message </span><span style="color:#fdf4c1;">SimState{
</span><span style="color:#fdf4c1;">  repeated BodyAttributes bodies </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">1</span><span style="color:#fdf4c1;">;
</span><span style="color:#fdf4c1;">}
</span></pre>
</code></pre></body></html>
<p>The Tonic Server is attached as a startup system in the Bevy ECS, and the
tokio runtime is added as a resource so the server can handle requests as
they come in asynchronously. We can connect to it on <code>localhost:50051</code>
and get the velocity and position of our bodies.</p>
<p>The client on the reciving end of the gRPC contract is implemented in
a seperate python script.</p>
<html><head></head><body><pre><code class="language-Python"><pre style="background-color:#282828;"><span style="color:#fa5c4b;">def </span><span style="color:#8ec07c;">set_configuration</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fdf4c1;">bodies</span><span style="color:#fdf4c1aa;">, </span><span style="color:#fdf4c1;">stub</span><span style="color:#fdf4c1aa;">):
</span><span style="color:#fdf4c1aa;">    </span><span style="font-style:italic;color:#928374;">"""
</span><span style="font-style:italic;color:#928374;">    Calls the SetConfiguration RPC to set the simulation configuration.
</span><span style="font-style:italic;color:#928374;">    """
</span><span style="color:#fdf4c1aa;">    sim_state </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">simulation_pb2.SimState(
</span><span style="color:#fdf4c1;">        bodies</span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1;">[
</span><span style="color:#fdf4c1;">            simulation_pb2.BodyAttributes(
</span><span style="color:#fdf4c1;">                bodyID</span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1;">body[</span><span style="color:#b8bb26;">"bodyID"</span><span style="color:#fdf4c1;">],
</span><span style="color:#fdf4c1;">                position</span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1;">simulation_pb2.Vec2D(
</span><span style="color:#fdf4c1;">                    x</span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1;">body[</span><span style="color:#b8bb26;">"position"</span><span style="color:#fdf4c1;">][</span><span style="color:#b8bb26;">"x"</span><span style="color:#fdf4c1;">], y</span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1;">body[</span><span style="color:#b8bb26;">"position"</span><span style="color:#fdf4c1;">][</span><span style="color:#b8bb26;">"y"</span><span style="color:#fdf4c1;">]
</span><span style="color:#fdf4c1;">                ),
</span><span style="color:#fdf4c1;">                velocity</span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1;">simulation_pb2.Vec2D(
</span><span style="color:#fdf4c1;">                    x</span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1;">body[</span><span style="color:#b8bb26;">"velocity"</span><span style="color:#fdf4c1;">][</span><span style="color:#b8bb26;">"x"</span><span style="color:#fdf4c1;">], y</span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1;">body[</span><span style="color:#b8bb26;">"velocity"</span><span style="color:#fdf4c1;">][</span><span style="color:#b8bb26;">"y"</span><span style="color:#fdf4c1;">]
</span><span style="color:#fdf4c1;">                ),
</span><span style="color:#fdf4c1;">                mass</span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1;">body[</span><span style="color:#b8bb26;">"mass"</span><span style="color:#fdf4c1;">],
</span><span style="color:#fdf4c1;">            )
</span><span style="color:#fdf4c1;">            </span><span style="color:#fa5c4b;">for </span><span style="color:#fdf4c1;">body </span><span style="color:#fa5c4b;">in </span><span style="color:#fdf4c1;">bodies
</span><span style="color:#fdf4c1;">        ]
</span><span style="color:#fdf4c1;">    )
</span><span style="color:#fdf4c1aa;">    response </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">stub.SetConfiguration(sim_state)
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fa5c4b;">def </span><span style="color:#8ec07c;">body_request</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fdf4c1;">stub</span><span style="color:#fdf4c1aa;">):
</span><span style="color:#fdf4c1aa;">    </span><span style="font-style:italic;color:#928374;">"""
</span><span style="font-style:italic;color:#928374;">    Requests the location, velocity, and mass of bodies in the current simulation
</span><span style="font-style:italic;color:#928374;">    """
</span><span style="color:#fdf4c1aa;">    request </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">simulation_pb2.SimCurrentStateReq()
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">try</span><span style="color:#fdf4c1aa;">:
</span><span style="color:#fdf4c1aa;">        response </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">stub.StateReply(request)
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fa5c4b;">return </span><span style="color:#fdf4c1aa;">response
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">except </span><span style="color:#fdf4c1aa;">grpc.RpcError </span><span style="color:#fa5c4b;">as </span><span style="color:#fdf4c1aa;">e:
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fabd2f;">print</span><span style="color:#fdf4c1;">(</span><span style="color:#fa5c4b;">f</span><span style="color:#b8bb26;">"gRPC call failed: </span><span style="color:#fdf4c1;">{e.code()}</span><span style="color:#b8bb26;">: </span><span style="color:#fdf4c1;">{e.details()}</span><span style="color:#b8bb26;">"</span><span style="color:#fdf4c1;">)
</span></pre>
</code></pre></body></html>
<p>Using the dictionary that the service provides, the client evaluates if
the simulation has effectively ended, or if the initial configuration no
longer has the chance of being stable. The "fail states" of the simulation
occur when either there was a collision or if one of the bodies escapes
from the orbit of the other two.</p>
<html><head></head><body><pre><code class="language-Python"><pre style="background-color:#282828;"><span style="color:#fa5c4b;">def </span><span style="color:#8ec07c;">collision</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fdf4c1;">bodies</span><span style="color:#fdf4c1aa;">):
</span><span style="color:#fdf4c1aa;">    </span><span style="font-style:italic;color:#928374;">"""
</span><span style="font-style:italic;color:#928374;">    returns true if body positions are within radii of one another
</span><span style="font-style:italic;color:#928374;">    """
</span><span style="color:#fdf4c1aa;">    combinations </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">itertools.combinations(bodies, </span><span style="color:#d3869b;">2</span><span style="color:#fdf4c1;">)
</span><span style="color:#fdf4c1aa;">    collision_flag </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">false
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">for </span><span style="color:#fdf4c1aa;">combination </span><span style="color:#fa5c4b;">in </span><span style="color:#fdf4c1aa;">combinations:
</span><span style="color:#fdf4c1aa;">        b1, b2 </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">combination
</span><span style="color:#fdf4c1aa;">        vec1 </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">np.array([b1.position.x, b1.position.y])
</span><span style="color:#fdf4c1aa;">        vec2 </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">np.array([b2.position.x, b2.position.y])
</span><span style="color:#fdf4c1aa;">        distance </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">np.linalg.norm(vec1 </span><span style="color:#fe8019;">- </span><span style="color:#fdf4c1;">vec2)
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fa5c4b;">if </span><span style="color:#fabd2f;">round</span><span style="color:#fdf4c1;">(distance, </span><span style="color:#d3869b;">2</span><span style="color:#fdf4c1;">) </span><span style="color:#fe8019;">&lt;= </span><span style="color:#d3869b;">80.0</span><span style="color:#fdf4c1aa;">:
</span><span style="color:#fdf4c1aa;">            collision_flag </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">true
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">return </span><span style="color:#fdf4c1aa;">collision_flag
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fa5c4b;">def </span><span style="color:#8ec07c;">escape</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fdf4c1;">bodies</span><span style="color:#fdf4c1aa;">):
</span><span style="color:#fdf4c1aa;">    </span><span style="font-style:italic;color:#928374;">"""
</span><span style="font-style:italic;color:#928374;">    returns true if a body is no longer effect by the gravitational force of one of the others
</span><span style="font-style:italic;color:#928374;">    """
</span><span style="color:#fdf4c1aa;">    combinations </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">itertools.combinations(bodies, </span><span style="color:#d3869b;">2</span><span style="color:#fdf4c1;">)
</span><span style="color:#fdf4c1aa;">    distance_flag </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">false
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">for </span><span style="color:#fdf4c1aa;">combination </span><span style="color:#fa5c4b;">in </span><span style="color:#fdf4c1aa;">combinations:
</span><span style="color:#fdf4c1aa;">        b1, b2 </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">combination
</span><span style="color:#fdf4c1aa;">        vec1 </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">np.array([b1.position.x, b1.position.y])
</span><span style="color:#fdf4c1aa;">        vec2 </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">np.array([b2.position.x, b2.position.y])
</span><span style="color:#fdf4c1aa;">        distance </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1;">np.linalg.norm(vec1 </span><span style="color:#fe8019;">- </span><span style="color:#fdf4c1;">vec2)
</span><span style="color:#fdf4c1aa;">        g_f </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">(b1.mass </span><span style="color:#fe8019;">* </span><span style="color:#fdf4c1aa;">b2.mass) </span><span style="color:#fe8019;">/ </span><span style="color:#fdf4c1aa;">(distance</span><span style="color:#fe8019;">**</span><span style="color:#d3869b;">2</span><span style="color:#fdf4c1aa;">)
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fa5c4b;">if </span><span style="color:#fabd2f;">round</span><span style="color:#fdf4c1;">(g_f, </span><span style="color:#d3869b;">3</span><span style="color:#fdf4c1;">) </span><span style="color:#fe8019;">== </span><span style="color:#d3869b;">0</span><span style="color:#fdf4c1aa;">:
</span><span style="color:#fdf4c1aa;">            distance_flag </span><span style="color:#fe8019;">= </span><span style="color:#fdf4c1aa;">true
</span><span style="color:#fdf4c1aa;">    </span><span style="color:#fa5c4b;">return </span><span style="color:#fdf4c1aa;">distance_flag
</span></pre>
</code></pre></body></html>
<p>I already implemented a simple genetic algorithm hoping to find some
stable configurations, it iterated with mild success, confirming that the
simulation-solver set up was working, although the method itself failed
due to its own simplicity, as each generation simply edged further away
while not triggering the <code>escape()</code> fail condition. From here I plan
to integrate a gradient descent algorithm with the formulization described
<a href="https://www.sciencedirect.com/science/article/pii/S1384107622001737">here</a>.
If you are reading this, I have not done so yet, au revouir.</p>
</body></html>
      </article>
    </main>
  </div>
  <script>
    window.MathJax = {
      loader: {load: ['[tex]/ams']},
      tex: {
        packages: {'[+]':['ams']},
        inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
        displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],
      },
      options: {
        // Only elements with one of these classes get processed
        processHtmlClass: 'math math-inline math-display',
        ignoreHtmlClass: 'no-mathjax'
      }
    };
  </script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

</body>
</html>