<!-- post.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>NoTeC</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Baskervville:ital@0;1&family=Bodoni+Moda:ital,opsz,wght@0,6..96,400..900;1,6..96,400..900&family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Newsreader:ital,opsz,wght@0,6..72,200..800;1,6..72,200..800&family=Wittgenstein:ital,wght@0,400..900;1,400..900&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="../tufte.css">
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
</head>
<body>
  <style>
  :not(pre) > code{
      background: #2b303b;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      overflow-x: auto;
  }
  pre.syntect,
  pre[class*="syntax"],
  pre.highlight,
  pre codeblock,          
  pre {
    max-width: 100%;
    overflow-x: auto;      
    overflow-y: hidden;     
    white-space: pre;        
    background: #111111
    -webkit-overflow-scrolling: touch;
  }
  </style>
  <nav class="nav editorial-nav">
    <div class="nav-center">
      <a href="../" class="nav-title divider-link">Sicarii</a>
    </div>
  </nav>

  <div class="editorial">
    <main class="post-container">
      <div class="post-header">
        <h1 class="post-title">NoTeC</h1>
        <div class="post-meta">
          <div class="author">Nico OR</div>
          <div class="date">2024-09-29</div>
        </div>
      </div>

      <article class="post-content">
        <html><head></head><body><p>To start, FSAE (Formula: Student Automotive Engineer) is a worldwide
competition aimed primarily at giving university students a competition to
exercise and apply the skills which they learn in the classroom. The
competition is aimed predominantly at mechanical engineering students, and
in recent years with the advent of the EV competition, electrical
engineering students. By way of demand, however, the FSAE chapter at UT
Dallas, a school overfilled with Computer Science Majors, offers several
large software and firmware projects. Here I focus on the project which
I have spent the most time on, the Data Acquisition Device (colloquially,
NoTeC, a joke I will explain later) and will hopefully circle back to the
other projects later.</p>
<p>The purpose of NoTeC is to sample different sensors through out the car,
and in some way get it to the engineers. How we serve the data to the
engineers has become increasingly more intricate and seamless over time.
Originally, the DAQ saved to a USB drive in CSV form, then it saved it to
an adjacent Raspberry Pi device, then the Raspberry Pi began sending and
syncing the data to a MongoDB database that can be quarried. Live
telemetry using Grafana is in the works, although there's some
practicality issues with getting WiFi to the Raspberry Pi without breaking
the rules of the competition.</p>
<p>The DAQ itself is currently implemented on an STM32F4 chip, but I am
currently migrating it to the STM32H7, on the basis of better performance.
It's written with the heavy help ST's HAL and C++. The impetus towards
using C++ is predominantly the ease of smart pointers, which allow me to
more easily make the system modular and hardware independent (we'll get
back to this). CMSIS-RTOS v2 is used for the threading.</p>
<p>The project structure:</p>
<pre><code>.
├── Application
│&nbsp;&nbsp; ├── DataLogger
│&nbsp;&nbsp; ├── FileSystem
│&nbsp;&nbsp; ├── Mutex
│&nbsp;&nbsp; └── Relay
├── Docs
│&nbsp;&nbsp; ├── data_logging
│&nbsp;&nbsp; ├── engine_control_unit
│&nbsp;&nbsp; ├── file_system
│&nbsp;&nbsp; ├── linear_potentiometer
│&nbsp;&nbsp; ├── peripheral_interfaces
│&nbsp;&nbsp; ├── _static
│&nbsp;&nbsp; └── stmicroelectronics
├── Platform
│&nbsp;&nbsp; ├── Interfaces
│&nbsp;&nbsp; └── STM
│&nbsp;&nbsp;     └── F4
│&nbsp;&nbsp;         ├── CAN
│&nbsp;&nbsp;         ├── GPIO
│&nbsp;&nbsp;         └── I2C
├── Sensor
│&nbsp;&nbsp; ├── Accelerometer
│&nbsp;&nbsp; ├── ECU
│&nbsp;&nbsp; │&nbsp;&nbsp; └── PE3
│&nbsp;&nbsp; │&nbsp;&nbsp;     └── Frames
│&nbsp;&nbsp; ├── GyroScope
│&nbsp;&nbsp; └── LinearPotentiometer
└── Tests
    └── Src
        ├── Application
        └── Sensor
            └── ECU
                └── PE3
</code></pre>
<p>The project is split into five parts which are, in order of their
proximity to "bare metal": Platform, Sensor, Application, and as auxiliary
systems, Tests and Docs. In the platform layer, we abstract away some of
the rougher edges of the HAL, making writing the actual application of the
DAQ a little less error prone. This also benefits the application insofar
as it decouples from the hardware. If I wanted to switch to an NXP chip
instead, I would only have to re implement this layer, as the Application
and Sensor layer uses the interfaces we make here.</p>
<p>Here is an example of one of the interfaces, the GPIO interface:</p>
<html><head></head><body><pre><code class="language-c++"><pre style="background-color:#282828;"><span style="color:#fdf4c1aa;">
</span><span style="color:#fa5c4b;">class </span><span style="color:#8ec07c;">IGpio </span><span style="color:#fdf4c1aa;">{
</span><span style="color:#fa5c4b;">public</span><span style="color:#fdf4c1aa;">:
</span><span style="color:#fdf4c1aa;">	</span><span style="color:#fa5c4b;">virtual </span><span style="color:#8ec07c;">~IGpio</span><span style="color:#fdf4c1aa;">() </span><span style="color:#fe8019;">= </span><span style="color:#fa5c4b;">default</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">	</span><span style="color:#fa5c4b;">virtual bool </span><span style="color:#8ec07c;">Read</span><span style="color:#fdf4c1aa;">() </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">0</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">	</span><span style="color:#fa5c4b;">virtual void </span><span style="color:#8ec07c;">Write</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fa5c4b;">bool </span><span style="color:#fdf4c1;">signal</span><span style="color:#fdf4c1aa;">) </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">0</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">	</span><span style="color:#fa5c4b;">virtual bool </span><span style="color:#8ec07c;">ToggleDetected</span><span style="color:#fdf4c1aa;">() </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">0</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">};
</span><span style="color:#fdf4c1aa;">
</span></pre>
</code></pre></body></html>
<p>And we implement the Write method like this</p>
<html><head></head><body><pre><code class="language-c++"><pre style="background-color:#282828;"><span style="color:#fa5c4b;">void </span><span style="color:#fdf4c1aa;">GpioStmF4::</span><span style="color:#8ec07c;">Write</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fa5c4b;">bool </span><span style="color:#fdf4c1;">signal</span><span style="color:#fdf4c1aa;">) {
</span><span style="color:#fdf4c1aa;">	GPIO_PinState pin_state;
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">	</span><span style="color:#fa5c4b;">if </span><span style="color:#fdf4c1aa;">(signal) {
</span><span style="color:#fdf4c1aa;">		pin_state </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> GPIO_PIN_SET;
</span><span style="color:#fdf4c1aa;">	} </span><span style="color:#fa5c4b;">else </span><span style="color:#fdf4c1aa;">{
</span><span style="color:#fdf4c1aa;">		pin_state </span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1aa;"> GPIO_PIN_RESET;
</span><span style="color:#fdf4c1aa;">	}
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">	</span><span style="color:#fdf4c1;">HAL_GPIO_WritePin(port_, pin_, pin_state)</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">}
</span><span style="color:#fdf4c1aa;">
</span></pre>
</code></pre></body></html>
<p>With this we cut down on how verbose our code is, and reduce how likely
a developer on the team is to misuse the (frankly dangerous) HAL.</p>
<p>The next layer, Sensor, does exactly what it sounds like, this is where we
create the sensor classes who interact with the interfaces we created in
the Platform layer. There also exists abstract interfaces for sensors,
hopefully making it easier to switch out the specific sensor used when we
need to, however we haven't really had the opportunity to put this to the
test as we haven't upgraded sensors in a long while.</p>
<p>For example, here's the interface for the linear potentiometer, which
reads the displacement of the suspension shocks.</p>
<html><head></head><body><pre><code class="language-c++"><pre style="background-color:#282828;"><span style="color:#fa5c4b;">class </span><span style="color:#8ec07c;">ILinearPotentiometer </span><span style="color:#fdf4c1aa;">{ </span><span style="color:#fa5c4b;">public</span><span style="color:#fdf4c1aa;">: </span><span style="color:#fa5c4b;">virtual </span><span style="color:#fe8019;">~</span><span style="color:#fdf4c1;">ILinearPotentiometer()
</span><span style="color:#fe8019;">= </span><span style="color:#fa5c4b;">default</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fa5c4b;">virtual void </span><span style="color:#8ec07c;">DisplacementInches</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fa5c4b;">float </span><span style="color:#fdf4c1;">quantized_counts</span><span style="color:#fdf4c1aa;">[]) </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">0</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">        </span><span style="color:#fa5c4b;">virtual void </span><span style="color:#8ec07c;">DisplacementMillimeters</span><span style="color:#fdf4c1aa;">(</span><span style="color:#fa5c4b;">float </span><span style="color:#fdf4c1;">quantized_counts</span><span style="color:#fdf4c1aa;">[]) </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">0</span><span style="color:#fdf4c1aa;">;
</span><span style="color:#fdf4c1aa;">};
</span></pre>
</code></pre></body></html>
<p>Lastly is the Application layer, which handles the state of the device,
our mutexes for multi-threading, and how we talk to the Raspberry Pi. This
is the most "userspace" the program gets.</p>
<p>The Tests folder has some preliminary unit tests made with gtest that are
hooked up to our GitHub CI/CD pipeline, but as with other "it'd be nice to
have" things in this project, I've yet to give it the time that it
deserves. Similarly the Docs folder has some documentation generation with
Phoenix, but I've yet to find the patience to annotate the existing code.</p>
</body></html>
      </article>
    </main>
  </div>
  <script>
    window.MathJax = {
      loader: {load: ['[tex]/ams']},
      tex: {
        packages: {'[+]':['ams']},
        inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
        displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],
      },
      options: {
        // Only elements with one of these classes get processed
        processHtmlClass: 'math math-inline math-display',
        ignoreHtmlClass: 'no-mathjax'
      }
    };
  </script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

</body>
</html>