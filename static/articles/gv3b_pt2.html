<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Great Value Three Body Problem</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Wittgenstein:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital@1&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Iosevka:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
  <link rel="stylesheet" href="../style.css">
</head>

<body>


<nav class="navbar">
  <ul>
    <li><a href="../">Home</a></li>
    <li><a href="../about/">About</a></li>
    <li><a href="../contact/">Contact</a></li>
  </ul>
</nav>


    <div class="container">
    <div class="title-wrapper">
        <h1 class="title">Great Value Three Body Problem</h1>
      <div class="author-date">
          <div class="author">Nico OR</div>
          <div class="date">2024-11-26</div>
      </div>
    </div>
    <div class="underline"></div>    
      <div class="text"><p>And we're back. I ended up making some changes to the simulation rig since
the last time I posted about this project. I ended up ditching the TOML
configuration, opting instead for the client to send a configuration, like
so:</p>
<pre><code class="language-c++">syntax = &quot;proto3&quot;;

package simulation;

service Sim {
  rpc StateReply(SimCurrentStateReq) returns (SimState) {}
  rpc SetConfiguration(SimState) returns (ConfigValid) {}
}

message SimCurrentStateReq{
  optional string bodyID = 1;
}

message Vec2D{
  float x = 1;
  float y = 2;
}

message ConfigValid{
  bool succeeded = 1;
}

message BodyAttributes{
  Vec2D velocity = 1;
  Vec2D position = 2;
  float mass = 3;
  uint32 bodyID = 4;
}

message SimState{
  repeated BodyAttributes bodies = 1;
}
</code></pre>
<p>I ended up changing some names too, as well as adding some more detail to
the <code>BodyAttributes</code> message. Now talking about the solver client. Since
the RPC contract between the server and client needs to be sync'd, and
I also wanted these two programs to be as decoupled as possible, I ended
up using PyBuilder to fetch the latest from the repository:</p>
<pre><code class="language-Python">@task
def get_protobuf_service_def(project):
    protobuf_url = &quot;https://raw.githubusercontent.com/NicoOhR/GV3B_simulation/refs/heads/main/proto/simulation.proto&quot;
    response = requests.get(protobuf_url)
    if response.status_code == 200:
        proto_dir = os.path.join(
            project.get_property(&quot;dir_source_main_python&quot;), &quot;proto&quot;
        )
        proto_file = os.path.join(proto_dir, &quot;simulation.proto&quot;)
        project.set_property(&quot;proto_dir&quot;, proto_dir)
        project.set_property(&quot;proto_file&quot;, proto_file)
        os.makedirs(proto_dir, exist_ok=True)
        with open(proto_file, &quot;wb&quot;) as file:
            file.write(response.content)
            print(&quot;[Builder] Successfuly got latest protobuf&quot;)
    else:
        print(&quot;[Builder] Failed to get protobuf&quot;)
        print(response.status_code)


@task
def build_proto_buf(project):
    proto_file = project.get_property(&quot;proto_file&quot;)
    proto_dir = project.get_property(&quot;proto_dir&quot;)
    module_file = os.path.join(proto_dir, &quot;__init__.py&quot;)
    command = [
        &quot;python3&quot;,
        &quot;-m&quot;,
        &quot;grpc_tools.protoc&quot;,
        &quot;-I&quot;,
        proto_dir,
        f&quot;--python_out={proto_dir}&quot;,
        f&quot;--grpc_python_out={proto_dir}&quot;,
        proto_file,
    ]
    ...
</code></pre>
<p>I fully recognize and appreciate that having a build system in a python
project might just be me being massively C-brained, but it gets the job
done and organizes the project pretty well. The actual client, being only
two methods, is pretty simple:</p>
<pre><code class="language-python">def set_configuration(bodies, stub):
    &quot;&quot;&quot;
    Calls the SetConfiguration RPC to set the simulation configuration.
    &quot;&quot;&quot;
    sim_state = simulation_pb2.SimState(
        bodies=[
            simulation_pb2.BodyAttributes(
                bodyID=body[&quot;bodyID&quot;],
                position=simulation_pb2.Vec2D(
                    x=body[&quot;position&quot;][&quot;x&quot;], y=body[&quot;position&quot;][&quot;y&quot;]
                ),
                velocity=simulation_pb2.Vec2D(
                    x=body[&quot;velocity&quot;][&quot;x&quot;], y=body[&quot;velocity&quot;][&quot;y&quot;]
                ),
                mass=body[&quot;mass&quot;],
            )
            for body in bodies
        ]
    )
    response = stub.SetConfiguration(sim_state)


def body_request(stub):
    &quot;&quot;&quot;
    Requests the location, velocity, and mass of bodies in the current simulation
    &quot;&quot;&quot;
    request = simulation_pb2.SimCurrentStateReq()
    try:
        response = stub.StateReply(request)
        return response
    except grpc.RpcError as e:
        print(f&quot;gRPC call failed: {e.code()}: {e.details()}&quot;)
</code></pre>
<p>Using the dictionary that the service gives us, we evaluate if the
simulation has effectively ended, or when the configuration no longer has
the chance of being stable. For our purposes that is when a collision has
occured, or when one of the bodies has escaped the gravitational force of
the others. That looks something like this:</p>
<pre><code class="language-Python">def collision(bodies):
    &quot;&quot;&quot;
    returns true if body positions are within radii of one another
    &quot;&quot;&quot;
    combinations = itertools.combinations(bodies, 2)
    collision_flag = false
    for combination in combinations:
        b1, b2 = combination
        vec1 = np.array([b1.position.x, b1.position.y])
        vec2 = np.array([b2.position.x, b2.position.y])
        distance = np.linalg.norm(vec1 - vec2)
        if round(distance, 2) &lt;= 80.0:
            collision_flag = true

    return collision_flag


def escape(bodies):
    &quot;&quot;&quot;
    returns true if a body is no longer effect by the gravitational force of one of the others
    &quot;&quot;&quot;
    combinations = itertools.combinations(bodies, 2)
    distance_flag = false
    for combination in combinations:
        b1, b2 = combination
        vec1 = np.array([b1.position.x, b1.position.y])
        vec2 = np.array([b2.position.x, b2.position.y])
        distance = np.linalg.norm(vec1 - vec2)
        g_f = (b1.mass * b2.mass) / (distance**2)
        if round(g_f, 3) == 0:
            distance_flag = true
    return distance_flag
</code></pre>
<p>In the same file I define some banal functions, <code>runtime</code> and
<code>create_config</code>, both of which do exactly what they sound like. We use
our runtime as the fitness matrix which we evolve our body configurations
with. Using the DEAP framework, I whipped up this genetic algorithm that
works... servicably</p>
<pre><code class="language-Python">
fitnesses = list(map(toolbox.evaluate, population))
for ind, fit in zip(population, fitnesses):
ind.fitness.values = fit

for gen in range(num_generations):
offspring = toolbox.select(population, len(population))
offspring = list(map(toolbox.clone, offspring))

for child1, child2 in zip(offspring[::2], offspring[1::2]):
    if np.random.rand() &lt; crossover_prob:
        toolbox.mate(child1, child2)
        del child1.fitness.values
        del child2.fitness.values

for mutant in offspring:
    if np.random.rand() &lt; mutation_prob:
        toolbox.mutate(mutant)
        del mutant.fitness.values

invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
fitnesses = map(toolbox.evaluate, invalid_ind)
for ind, fit in zip(invalid_ind, fitnesses):
    ind.fitness.values = fit

population[:] = offspring

fits = [ind.fitness.values[0] for ind in population]
</code></pre>
<p>the algorithm is pretty textbook (DEAP textbook to be specific). But it
does iterate, slowly. I tried using the SciPy optimize package, but that
never got up and running, and back propogation never made it back up the
computation graph when using PyTorch (since, surprisingly, gRPC is not
auto-differentiable)</p>
</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
        });
    </script>
</body>

</html>